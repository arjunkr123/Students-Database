/** * Create a page to manage an exam_subject object<br/> * The main structure of the page is based on a table * @param {Object}subject a JSON exam_subject object * @param {String|HTMLElement} container the container (or its ID) where the page will be generated * @param {Boolean}can_edit * @param {Boolean}can_remove * @param {Boolean}can_add * @param {Boolean}display_correct_answer the value of the selection config attribute. If yes, a column is added for the correct answers, and the field becomes mandatory for the check before saving * @param {Boolean}display_choices the value of the selection config attribute. If yes, a column is added for the display choices, and the field becomes mandatory for the check before saving * @param {Boolean}no_question true if only need to display the list of the parts within the subject, not the question detail (in that case, the part objects can be given with empty questions arrays)<br/>Note: in that case the exam subject cannot be editable  * @param {Number}campaign_id the id of the current campaign id, used for the databaselock management * @param {Boolean}read_only if true, some temporary rights are created by the editable_read_only_manager object and the page is generated in a read_only mode * @param {Number|Null}db_lock the databaselock id created before generating the page content. Can be null if read_only, and also if the subject is new and has never been saved yet */function manage_exam_subject(subject, container, can_edit, can_remove, can_add, display_correct_answer,display_choices,no_question,campaign_id, read_only, db_lock){	var t = this;	t.ordered = null;	t.allReseters = [];	t.table = document.createElement("table");	t.full_dislayed_parts = {};	t.db_lock = db_lock;	t.global_can_edit = null;	t.global_can_remove = null;	t.global_can_add = null;	if(typeof container == "string")		container = document.getElementById(container);	container.style.backgroundColor = "FFFFFF";	t.popup_container = window.parent.get_popup_window_from_frame(window);		/**	 * Launch the process<br/>	 * Once everything is ready and if the exam is new, a focus is done on the exam_name input	 */	t._init = function(){		//get the updated values of global rights and db_lock		t.global_can_edit = t.editable_manager.getCanEdit();		t.global_can_add = t.editable_manager.getCanAdd();		t.global_can_remove = t.editable_manager.getCanRemove();		t.db_lock = t.editable_manager.getDBLock();		t._addPageButtons(); //manage the back, save, remove buttons		t.editable_manager.manageButtons(); // manage the edit and unedit buttons		t._setHeaderContent();		t._setTableBody();				t._setTableStyle();		container.appendChild(t.table);		//if the exam subject is new we focus on the exam_name input		if(subject.name == "New Exam" && subject.parts.length == 0){			t._focusOnInput("exam_name");		}	};		/**	 * Set the header of the table<br/>	 * If editable, a text input is set for the exam name	 */	t._setHeaderContent = function(){		if(typeof t.thead != "undefined"){			t.table.removeChild(t.thead);			delete t.thead;		}		t.thead = document.createElement("thead");		var max_score = 0;		for (var i = 0; i < subject.parts.length; i++){			var score = subject.parts[i].max_score;			if(typeof(score) == "string")				score = parseFloat(score);			if(isNaN(score))				score = 0;			max_score = max_score + score;		}		var th2 = document.createElement("th");		th2.colSpan = 2;		if(t.global_can_edit){			var th1 = document.createElement("th");			th1.colSpan = 2;			var input = document.createElement("input");			input.type = "text";			input.value = subject.name.uniformFirstLetterCapitalized();			if(input.value == "New Exam"){				input.style.color = "#808080";				input.style.fontStyle = "italic";			}			input.onfocus = function(){				this.style.color = "";				this.style.fontStyle = "";				if(this.value == "New Exam")					this.value = null;			};			input.onblur = function(){				if(this.value == null || (this.value != null && !this.value.checkVisible())){					this.value = "New Exam";					this.style.color = "#808080";					this.style.fontStyle = "italic";				} else					this.value = this.value.uniformFirstLetterCapitalized();				subject.name = this.value;			};			input.style.fontSize = "x-large";			input.style.textAlign = "center";			input.id = "exam_name";			inputAutoresize(input,20);			var text = subject.parts.length+" "+getGoodSpelling("part",subject.parts.length)+ " - Max score: "+max_score+" "+getGoodSpelling("point",max_score);			var text_node = document.createTextNode(text);			th1.appendChild(input);			th2.appendChild(text_node);			var tr1 = document.createElement("tr");			var tr2 = document.createElement("tr");			tr1.appendChild(th1);			tr2.appendChild(th2);			t.thead.appendChild(tr1);			t.thead.appendChild(tr2);		} else {			th2.innerHTML ="<div style = 'font-size:x-large'>"+subject.name.uniformFirstLetterCapitalized()+"</div></br> "+subject.parts.length+" "+getGoodSpelling("part",subject.parts.length)+ " - Max score: "+max_score+" "+getGoodSpelling("point",max_score);			t.thead.appendChild((document.createElement("tr")).appendChild(th2));		}		t.table.appendChild(t.thead);		//update subject object		subject.max_score = max_score;	};		/**	 * Set the body of the table<br/>	 * Rows are generated for each parts within the subject.<br/>	 * Each part row contains a manage_exam_subject_part_questions object<br/>	 * Two buttons are added at the end of the part header:<ul>	 * <li>A remove button to remove the part from the subject</li>	 * <li>A set index button to move a part into the subject (update its index)</li>	 * </ul><br/>	 * A show / hide part detail button is added at the begining of the part row. This button enables the user to hide or display the questions from a part<br/>	 * When clicked, this button update the t.full_dislayed_parts attribute. This way, when the page is reseted, the hidden parts are still hidden.<br/>	 * Three customs event listener are added on the manage_exam_subject_part_questions objects:<ul>	 * <li><code>onmanagerow</code> Called each time a question row is added / removed. This way the total figures (score...) displayed in the table header are updated. Also, the part and all the following ones are reseted (add the part row and update the number of question before for the following parts, so the question index is updated)</li>	 * <li><code>onupdatescore</code> Called each time a question score is updated by the user. This way the total figures (score...) displayed in the table header are updated</li>	 * <li><code>focusonagiveninput</code> Called each time a question is added to the part. This way the focus is given to the new question score input</li>	 * </ul><br/>	 * The manage_exam_subject_part_questions reset method is retrieved and stored into the t.allReseters attribute. When the subject table is reseted, all the parts tables (from manage_exam_subject_part_questions object) are reseted too 	 */	t._setTableBody = function(){		var tbody = document.createElement("tbody");		if(subject.parts.length == 0){			t.ordered = [];			var td = document.createElement("td");			td.innerHTML = "<i>This exam subject has no part yet</i>";			td.style.paddingTop = "25px";			td.colSpan = 2;						if(t.global_can_edit){				var b = t._createInsertPartButton();				b.style.marginLeft = "5px";				td.appendChild(b);			}			var tr = document.createElement("tr");			tr.appendChild(td);			tbody.appendChild(tr);					} else {			t.ordered = t._getOrderedParts();			for(var i = 0; i < subject.parts.length; i++){				var tr1 = document.createElement("tr");				var td11 = document.createElement("td");				td11.style.paddingTop = "30px";				var td12 = document.createElement("td");				td12.style.paddingTop = "25px";				var remove_button = t._createButton("remove");				var index_button = t._createButton("change_index");				var cont_buttons = null;				if(t.global_can_edit){					cont_buttons = document.createElement("div");					cont_buttons.appendChild(remove_button);					cont_buttons.appendChild(index_button);					cont_buttons.style.display = "inline-block";					cont_buttons.style.paddingLeft = "10px";				}				var show_button = t._createButton("hide_detail");				if(typeof(t.full_dislayed_parts[subject.parts[t.ordered[i]].index]) == "undefined")					t.full_dislayed_parts[subject.parts[t.ordered[i]].index] = true;				if(t.full_dislayed_parts[subject.parts[t.ordered[i]].index] == false)					show_button.innerHTML = "<img src = '/static/widgets/tree/plus.png'/>";				show_button.td = td12;				td11.appendChild(show_button);				td11.style.verticalAlign = "top";				show_button.index = i;				show_button.onclick = function(){					var t2 = this;					if(this.part.getDisplayQuestionDetail()){						delete this.part;						this.td.removeChild(this.div_part);						delete this.div_part;						this.div_part = document.createElement("div");						this.part = new manage_exam_subject_part_questions(							subject.parts[t.ordered[t2.index]],							t2.div_part,							t.global_can_edit, //if the user can edit a subject, he can remove/add questions							t.global_can_edit,							t.global_can_edit,							false,							display_correct_answer,							display_choices,							t._getQuestionsBefore(t2.index),							no_question,							cont_buttons						);						this.part.onmanagerow.add_listener(t.resetPartsAndHeader);						this.part.onupdatescore.add_listener(t._setHeaderContent);						this.part.focusonagiveninput.add_listener(t._focusOnInput);						this.td.appendChild(t2.div_part);						this.innerHTML = "<img src = '/static/widgets/tree/plus.png'/>";						t.full_dislayed_parts[subject.parts[t.ordered[t2.index]].index] = false;					} else {						delete this.part;						this.td.removeChild(this.div_part);						delete this.div_part;						this.div_part = document.createElement("div");						this.part = new manage_exam_subject_part_questions(							subject.parts[t.ordered[t2.index]],							t2.div_part,							t.global_can_edit,							t.global_can_edit,							t.global_can_edit,							true,							display_correct_answer,							display_choices,							t._getQuestionsBefore(t2.index),							no_question,							cont_buttons						);						this.part.onmanagerow.add_listener(t.resetPartsAndHeader);						this.part.onupdatescore.add_listener(t._setHeaderContent);						this.part.focusonagiveninput.add_listener(t._focusOnInput);						this.td.appendChild(t2.div_part);						this.innerHTML = "<img src = '/static/widgets/tree/minus.png'/>";						t.full_dislayed_parts[subject.parts[t.ordered[t2.index]].index] = true;					}					// update the reseter					t.allReseters[this.index] = this.part.reset;				};				show_button.div_part = document.createElement("div");				show_button.part = new manage_exam_subject_part_questions(					subject.parts[t.ordered[i]],					show_button.div_part,					t.global_can_edit,					t.global_can_edit,					t.global_can_edit,					t.full_dislayed_parts[subject.parts[t.ordered[i]].index],					display_correct_answer,					display_choices,					t._getQuestionsBefore(i),					no_question,					cont_buttons				);				t.allReseters[i] = show_button.part.reset;				show_button.part.onmanagerow.add_listener(t.resetPartsAndHeader);				show_button.part.onupdatescore.add_listener(t._setHeaderContent);				show_button.part.focusonagiveninput.add_listener(t._focusOnInput);				td12.appendChild(show_button.div_part);				/**				 * Manage the buttons				 */				index_button.title = "Change the part index in the subject";				remove_button.index_in_parts = t.ordered[i];				remove_button.title = "Remove the part";				remove_button.onclick = function(){					var t2 = this;					var pop = new popup_window("Remove a part",theme.icons_16.question,"<center>Do you really want to remove this part<br/> and <b>all</b> the questions inside?</center>");					pop.addOkCancelButtons(function(){						t._removePart(t2.index_in_parts);						pop.close();					});					pop.show();				};				index_button.index_in_parts = t.ordered[i];				index_button.title = "Move the part";				index_button.onclick = function(){					var t2 = this;					var cont = document.createElement("div");					var div = document.createElement("div");					var text = document.createElement("div");					cont.appendChild(text);					cont.appendChild(div);					text.innerHTML = "Select the new index";					var pop = new popup_window(								"Set the index",								theme.icons_16.question,								cont							);					for(var j = 0; j < t.ordered.length; j++){						var b = t._createButton(j+1);						if(subject.parts[t2.index_in_parts].index == j+1)							b.style.backgroundColor = "rgb(17, 225, 45)";						b.index = j+1;						b.onclick = function(){							t._setIndex(t2.index_in_parts, this.index);							pop.close();						};						div.appendChild(b);					}					pop.show();				};				tr1.appendChild(td11);				tr1.appendChild(td12);				tbody.appendChild(tr1);								if(i == subject.parts.length - 1 && t.global_can_edit){					var td_insert_part = document.createElement("td");					td_insert_part.colSpan = 2;					td_insert_part.style.paddingTop = "15px";					var tr_insert_part = document.createElement("tr");					td_insert_part.appendChild(t._createInsertPartButton());					tr_insert_part.appendChild(td_insert_part);					tbody.appendChild(tr_insert_part);				}			}		}		t.table.appendChild(tbody);	};		/**	 * The the index attribute of a part. Method called by the set index button (added on the part header row).<br/>	 * Update the index attribute from the part object, and update all the other parts index attributes<br/>	 * When the updates are done, the subject table is reseted	 * @param {Number} index_in_parts the index of the part in the subject.parts array	 * @param {Number} new_index_attribute the value of the part.index attribute to set	 */	t._setIndex = function(index_in_parts, new_index_attribute){		var actual_index_attribute = parseInt(subject.parts[index_in_parts].index);		if(actual_index_attribute > new_index_attribute){			//increase the indexes before			for(var i = new_index_attribute; i < actual_index_attribute; i++)				subject.parts[t.ordered[i-1]].index = parseInt(subject.parts[t.ordered[i-1]].index) + 1;			//set the new value			subject.parts[t.ordered[actual_index_attribute-1]].index = new_index_attribute;			//reset			t.reset();		} else if(actual_index_attribute < new_index_attribute){			//decrease the ones after			var temp = parseInt(new_index_attribute) +1;			for(var i = actual_index_attribute +1; i < temp; i++)				subject.parts[t.ordered[i-1]].index = parseInt(subject.parts[t.ordered[i-1]].index) -1;			//set the new value			subject.parts[t.ordered[actual_index_attribute-1]].index = new_index_attribute;			//reset			t.reset();		}		// if actual_index_attribute == new_index_attribute, nothing to do	};		/**	 * Remove a part from the subject object. THis method is called by the remove part button<br/>	 * When a part is removed, all the following parts indexes are decreased, calling the _decreaseIndexAttribute method	 * @param {Number} index_in_parts the index of the part in the subject.parts array	 */	t._removePart = function(index_in_parts){		//update the index attribute of the following parts		t._decreaseIndexAttribute(parseInt(subject.parts[index_in_parts].index) -1);		//remove the part		subject.parts.splice(index_in_parts,1);		//reset table		t.reset();	};		/**	 * Decrease of 1 the index attribute of a given part	 * @param {Number} index_in_ordered The index of the part into the t.ordered attribute	 */	t._decreaseIndexAttribute = function(index_in_ordered){		if(typeof(index_in_ordered != "number"))			index_in_ordered = parseInt(index_in_ordered);		//if last part, nothing to do		if(index_in_ordered != t.ordered.length -1){			var j = index_in_ordered;			i = 1;			while(j != t.ordered.length){				subject.parts[t.ordered[index_in_ordered + i]].index = parseInt(subject.parts[t.ordered[index_in_ordered + i]].index) -1;				i++;				j = index_in_ordered + i;			}		}	};		/**	 * Create an insert part button, at the end of the subject table<br/>	 * This button create a new exam_subject_part object and add a first question to this part.<br/>	 * At the end of the process the subject table is reseted and the focus is done on the new question score input 	 */	t._createInsertPartButton = function(){		var insert_part = t._createButton("insert_part");		insert_part.onclick = function(){			// insert a part in subject with a first question			var length = subject.parts.length;			var new_index = t.ordered.length +1;			var new_questions = [];			var first_question = new ExamSubjectQuestion(-1,1,1,null,null);			new_questions.push(first_question);			subject.parts.push(new ExamSubjectPart(-1,new_index,"",1,new_questions));//Score is initiated at 1 because by default the score of the question inserted is 1				//Update the header score			t._setHeaderContent();			// reset			t.reset();			//focus			t._focusOnInput("question"+subject.parts[length].index+"."+1);		};		return insert_part;	};		/**	 * Set the style of the table	 */	t._setTableStyle = function(){		t.table.style.backgroundColor = "white";		t.table.style.paddingLeft = "20px";		t.table.style.paddingRight = "20px";		t.table.style.paddingTop = "20px";		t.table.style.paddingBottom = "20px";	};		/**	 * Add buttons to the popup window<br/>	 * Save, remove are added, depending on the user rights<br/>	 * Export and back buttons are always added <br/>	 * The edit / unedit buttons are managed by the editable_read_only_manager	 */	t._addPageButtons = function(){		t.popup_container.addIconTextButton(theme.icons_16._export, "Export", "export", function() { t._export_menu(this); });		if(t.global_can_edit && (t.global_can_add || (subject.id != -1 && subject.id != "-1")))			t.popup_container.addIconTextButton(theme.icons_16.save, "Save", "save", function() {				t.popup_container.freeze("Saving...");				//Check no question is empty				var no_empty_question = t._noEmptyQuestion();				var no_empty_choices = [true,null];				var no_empty_correct_answer = [true,null];				if(display_correct_answer)					no_empty_correct_answer = t._noEmptyGivenField("correct_answer","You haven't filled up the choices column for the following questions","These fields are mandatory");				if(display_choices)					no_empty_choices = t._noEmptyGivenField("choices","You haven't filled up the choices column for the following questions","These fields are mandatory");				var name_updated = true;				var name_already_exists = false;				service.json("selection","exam/get_all_subject_names",{exclude_id:subject.id},function(res){					if(!res){						name_already_exists = false;					} else {						if(!t._nameDoesNotAlreadyExist(subject.name.uniformFirstLetterCapitalized(), res))							name_already_exists = true;					}				},true);				if(subject.name.uniformFirstLetterCapitalized() == "New Exam")					name_updated = false;				if(no_empty_question[0] && no_empty_choices[0] && no_empty_correct_answer[0] && name_updated && !name_already_exists){					service.json("selection","exam/save_subject",{exam:subject},function(res){						t.popup_container.unfreeze();						if(!res)							error_dialog("An error occured, your informations were not saved");						else {							//update subject							subject = res;							//reset							t.reset();							window.top.status_manager.add_status(new window.top.StatusMessage(window.top.Status_TYPE_OK, "Your informations have been successfuly saved!", [{action:"close"}], 5000));						}					});				} else {					t.popup_container.unfreeze();					if(!no_empty_question[0])						error_dialog(no_empty_question[1]);					if(!name_updated){						error_dialog("You must set an exam name");						t._focusOnInput("exam_name");					}					if(name_already_exists){						error_dialog("An exam subject already exists with the same name for this selection campaign");						t._focusOnInput("exam_name");					}					if(!no_empty_correct_answer[0])						error_dialog(no_empty_correct_answer[1]);					if(!no_empty_choices[0])						error_dialog(no_empty_choices[1]);				}			});		if(t.global_can_remove && subject.id != -1 && subject.id != "-1")			t.popup_container.addIconTextButton(theme.icons_16.remove, "Remove this subject", "remove", function() {				confirm_dialog("<center>Do you want to remove this exam,<br/> and all the informations related? (Questions, parts...)</center>",					function(answer){						if(answer){							t.popup_container.freeze("Removing subject...");							if(subject.id != -1 && subject.id != "-1")								// remove from database								service.json("selection","exam/remove_subject",{id:subject.id},function(res){									t.popup_container.unfreeze();									if(!res)										error_dialog("An error occured");									else										t.popup_container.close();								});							else								t.popup_container.close();						}					}				);			});	};		/**	 * Method called by the export button. Create a context menu to show the possible exports formats	 * @param {HTMLElement} button the export button. The menu will be displayed below this one	 */	t._export_menu = function(button) {		require("context_menu.js",function(){			var menu = new context_menu();			menu.removeOnClose = true;			menu.addTitleItem(null, "Export Format");			menu.addIconItem('/static/data_model/excel_16.png', 'Excel 2007 (.xlsx)', function() { t._export_list('excel2007'); });			menu.addIconItem('/static/data_model/excel_16.png', 'Excel 5 (.xls)', function() { t._export_list('excel5'); });			menu.addIconItem('/static/selection/exam/sunvote_16.png', 'SunVote ETS compatible format', function() { t._export_list('excel2007',true); });			menu.showBelowElement(button);		});	};		/**	 * Method called by the Export context menu icons items<br/>	 * A form is created, containing all the data required by the selection/service/exam/export_subject service<br/>	 * This form is added to the document body and hidden. Once filled, the form is submitted to transfer all the data to the service	 * @param {String} format	 * @param {Boolean} compatible_clickers true if the exported file must match with the Sunvote ETS expected format	 */	t._export_list = function(format,compatible_clickers){		var form = document.createElement('form');		form.action = "/dynamic/selection/service/exam/export_subject";		form.method = "POST";		var input = document.createElement("input");		input.type = "hidden";		input.name = "format";		input.value = format;		form.appendChild(input);		var input2 = document.createElement("input");		input2.type = "hidden";		input2.value = service.generateInput(subject);		input2.name = "subject";		form.appendChild(input2);		if(compatible_clickers){			var input3 = document.createElement("input");			input3.type = "hidden";			input3.value = "true";			input3.name = "clickers";			form.appendChild(input3);		}		document.body.appendChild(form);		form.submit();	};		/**	 * Check that the subject name does not already exist into the database (exam subject name must be unique)	 * @param {String} name	 * @param {Array} all_subject_names array containing all the subjects set into the database	 * @returns {Boolean} true if the name is unique 	 */	t._nameDoesNotAlreadyExist = function(name, all_subject_names){		var unique = true;		var name2 = null;		if(name != "" && name != null){				name2 = name.uniformFirstLetterCapitalized();			for(var i = 0; i < all_subject_names.length; i++){				if(name2 == all_subject_names[i].uniformFirstLetterCapitalized()){					unique = false;					break;				}			}		}		return unique;	};		/**	 * Check that each question object has at least a score attribute <> null and greater than 0	 * @returns {Array} <ul><li>[0]: {Boolean} true if no exception has been detected</li>	 * 					<li>[1]: {String} Error message to display</li>	 */	t._noEmptyQuestion = function(){		var no_empty = true;		var error_message = "";		var res = [];		var first_error = true;		for(var i = 0; i < subject.parts.length; i++){			for(var j = 0; j < subject.parts[i].questions.length; j++){				if(subject.parts[i].questions[j].max_score == null || subject.parts[i].questions[j].max_score == "" || parseFloat(subject.parts[i].questions[j].max_score) <= 0.00){					no_empty = false;					if(first_error)						error_message += "You have not set a score (<b>number > 0</b>) to the following questions:<br/><ul>";					first_error = false;					var questions_before = parseInt(t._getQuestionsBefore(subject.parts[i].index -1));					var index = parseInt(subject.parts[i].questions[j].index) + questions_before;					error_message += "<li>Part "+subject.parts[i].index+", question "+index+"</li>";				}			}		}		if(!no_empty)			error_message += "</ul><br/><center><i>The score field is mandatory</i></center>";		res[0] = no_empty;		res[1] = error_message;		return res;	};		/**	 * Checks that all the given fields_name are not empty	 * @param {String} field_name (choices|correct_answer)	 * @param {String} error_message_first_row First row to display on the generated error message	 * @param {String} error_message_last_row Last row to display on the generated error message	 * @returns {Array} <ul><li>[0]: {Boolean} true if no exception has been detected</li>	 * 					<li>[1]: {String} Error message to display</li>	 */	t._noEmptyGivenField = function(field_name,error_message_first_row,error_message_last_row){		var no_empty = true;		var error_message = "";		var res = [];		var first_error = true;		for(var i = 0; i < subject.parts.length; i++){			for(var j = 0; j < subject.parts[i].questions.length; j++){				if(subject.parts[i].questions[j][field_name] == null || subject.parts[i].questions[j][field_name] == ""){					no_empty = false;					if(first_error){						error_message += error_message_first_row;						error_message += ":<br/><ul>";					}					first_error = false;					var questions_before = parseInt(t._getQuestionsBefore(subject.parts[i].index -1));					var index = parseInt(subject.parts[i].questions[j].index) + questions_before;					error_message += "<li>Part "+subject.parts[i].index+", question "+index+"</li>";				}			}		}		if(!no_empty){			error_message += "</ul><br/><center><i>";			error_message += error_message_last_row;			error_message += "</i></center>";		}		res[0] = no_empty;		res[1] = error_message;		return res;	};		/**	 * Get the number of questions of all the parts before the given one, to be able to instanciate the manage_exam_subject_part_question with the good value of question_before<br/>	 * This is used to set the diqplayed index of the question (auestion index attribute stored into the database is the index of the question within the part)	 * @param {Number} index_in_ordered the index of the part into t.ordered array	 * @returns {Number} question_before	 */	t._getQuestionsBefore = function(index_in_ordered){		var questions_before = null;		if(index_in_ordered == 0)			questions_before = 0;		else {			for(var i = 0; i < index_in_ordered; i++){				var count = subject.parts[t.ordered[i]].questions.length;				if(isNaN(count))					count = parseInt(count);				questions_before = questions_before + count;			}		}		return questions_before;	};		/**	 * Get an array containing the part index in the subject.parts array, ordered according to the parts indexes attributes	 * @returns {Array} array containing the parts indexes in subject.parts	 */	t._getOrderedParts = function(){		var ordered = [];		for(var i = 1; i < subject.parts.length + 1; i++){			ordered[i-1] = t._getPartIndexInSubject(i);		}		return ordered;	};		/**	 * Get the part index in subject.parts array, from its index attribute	 * @param {Number} part_index_attribute	 * @returns {Number|Null} null if not found, else the index into subject.parts array	 */	t._getPartIndexInSubject = function(part_index_attribute){		var index = null;		for(var i = 0; i < subject.parts.length; i++){			if(subject.parts[i].index == part_index_attribute){				index = i;				break;			}		}		return index;	};		/**	 * Create a div with the className button	 * @param {String} content the innerHTML of the button	 * @returns {HTMLElement} button	 */	t._createButton = function(content){		var button = document.createElement("BUTTON");		if(content == "show_detail"){			button.innerHTML = "<img src = '/static/widgets/tree/plus.png'/>";			button.className = "";			button.title = "Show part detail";			button.style.cursor = "pointer";		} else if(content == "hide_detail") {			button.innerHTML = "<img src = '/static/widgets/tree/minus.png'/>";			button.className = "";			button.title = "Hide part detail";			button.style.cursor = "pointer";		} else if(content == "remove"){			button.innerHTML = "<img src = '"+theme.icons_16.remove+"'/>";			button.className = "button_verysoft";		}		else if(content == "rename")			button.innerHTML = "<img src = '"+theme.icons_16.edit+"'/> Rename";		else if(content == "change_index"){			button.innerHTML = "<img src = '"+theme.icons_16.move+"'/>";			button.className = "button_verysoft";		} else if(content == "insert_part")			button.innerHTML = "<img src = '"+theme.icons_16.add+"'/> Add a part";		else if(content == "remove_exam"){			button.className = "button_verysoft";			button.innerHTML = "<img src = '"+theme.icons_16.remove+"'/> Remove exam";		}		else if(content == "save"){			button.className = "button_verysoft";			button.innerHTML = "<img src = '"+theme.icons_16.save+"'/> <b>Save</b>";		} else			button.innerHTML = content;		return button;	};		/**	 * Get the part index knowing the number of questions before. This method is used when the parts reseter are called, to start reseting with a given offset	 * @param {Number} question_index_before_part the number of questions before the part seeked	 * @returns {Number} the part index into subject.parts array	 */	t._getPartIndexFromNumberOfQuestionsBefore = function(question_index_before_part){		var number_questions = 0;		var part_index = 0;		if(question_index_before_part == 0)			part_index = 0;		else {			while(number_questions < question_index_before_part && part_index < t.ordered.length){				number_questions = number_questions + parseFloat(subject.parts[t.ordered[part_index]].questions.length);				part_index++;			}		}		return part_index;	};		/**	 * Focus on a given input and select its inner text, if the input is found	 * @param {String} id of the input	 */	t._focusOnInput = function(id){		var input = document.getElementById(id);		if(input != null){			input.focus();			input.select();		}	};		/**	 * Reset the parts tables and the subject table header, starting after a given number of question	 * @param {Number} question_index_before_part the number of questions before the first part to reset. This parameter is used to call the _getPartIndexFromNumberOfQuestionsBefore method	 */	t.resetPartsAndHeader = function(question_index_before_part){		if(typeof(question_index_before_part) != "undefined" && subject.parts.length > 0)			var start = t._getPartIndexFromNumberOfQuestionsBefore(question_index_before_part);		t.table.removeChild(t.thead);		delete t.thead;		t._setHeaderContent();		if(typeof(start) == "undefined")			var start = 0;		//launch reset only for the parts after the one that fired onmanagerow		for(var i = start; i < t.ordered.length; i++){			t.allReseters[i](t._getQuestionsBefore(i));		}	};		/**	 * Reset the table, and all the parts tables	 */	t.reset = function(){		for(var i = 0; i < t.allReseters.length; i++)			t.allReseters[i]();		t.table.removeChild(t.thead);		delete t.thead;		container.removeChild(t.table);		delete t.table;		t.table = document.createElement("table");		delete t.ordered;		t.ordered = null;		t.popup_container.removeButtons();		t._init();	};		/**	 * Launch the process after including all the required javascripts files. An editable_read_only_manager is added	 */	require(["manage_exam_subject_part_questions.js","popup_window.js","exam_objects.js","input_utils.js","editable_read_only_manager.js"],function(){		t.editable_manager = new editable_read_only_manager(				can_edit,				can_add,				can_remove,				t.global_can_edit,				t.global_can_add,				t.global_can_remove,				"row",				"ExamSubject",				null,				subject.id,				campaign_id,				t.db_lock,				function(){if(subject.id != -1 && subject.id != "-1")return true;},				t.reset,				function(){service.json("selection","exam/get_subject",{id:subject.id},function(r){if(r) topic = r},true);}, //must wait for the service before reseting				function(){if(subject.id == -1) error_dialog("You cannot go to uneditable mode because the topic has never been saved yet"); else return true;},				function(button) { t.popup_container.addFooter(button); },				null				);		t.editable_manager.setGlobalRights(read_only);//		t.editable_manager.lockDatabase(t._init,t._init);		t._init();	});}